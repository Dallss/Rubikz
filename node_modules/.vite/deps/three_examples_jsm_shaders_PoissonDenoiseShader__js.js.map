{
  "version": 3,
  "sources": ["../../three/examples/jsm/shaders/PoissonDenoiseShader.js"],
  "sourcesContent": ["import {\r\n\tMatrix4,\r\n\tVector2,\r\n\tVector3,\r\n} from 'three';\r\n\r\n/**\r\n * References:\r\n * https://openaccess.thecvf.com/content/WACV2021/papers/Khademi_Self-Supervised_Poisson-Gaussian_Denoising_WACV_2021_paper.pdf\r\n * https://arxiv.org/pdf/2206.01856.pdf\r\n */\r\n\r\nconst PoissonDenoiseShader = {\r\n\r\n\tname: 'PoissonDenoiseShader',\r\n\r\n\tdefines: {\r\n\t\t'SAMPLES': 16,\r\n\t\t'SAMPLE_VECTORS': generatePdSamplePointInitializer( 16, 2, 1 ),\r\n\t\t'NORMAL_VECTOR_TYPE': 1,\r\n\t\t'DEPTH_VALUE_SOURCE': 0,\r\n\t},\r\n\r\n\tuniforms: {\r\n\t\t'tDiffuse': { value: null },\r\n\t\t'tNormal': { value: null },\r\n\t\t'tDepth': { value: null },\r\n\t\t'tNoise': { value: null },\r\n\t\t'resolution': { value: new Vector2() },\r\n\t\t'cameraProjectionMatrixInverse': { value: new Matrix4() },\r\n\t\t'lumaPhi': { value: 5. },\r\n\t\t'depthPhi': { value: 5. },\r\n\t\t'normalPhi': { value: 5. },\r\n\t\t'radius': { value: 4. },\r\n\t\t'index': { value: 0 }\r\n\t},\r\n\r\n\tvertexShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tvoid main() {\r\n\t\t\tvUv = uv;\r\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\r\n\t\t}`,\r\n\r\n\tfragmentShader: /* glsl */`\r\n\r\n\t\tvarying vec2 vUv;\r\n\r\n\t\tuniform sampler2D tDiffuse;\r\n\t\tuniform sampler2D tNormal;\r\n\t\tuniform sampler2D tDepth;\r\n\t\tuniform sampler2D tNoise;\r\n\t\tuniform vec2 resolution;\r\n\t\tuniform mat4 cameraProjectionMatrixInverse;\r\n\t\tuniform float lumaPhi;\r\n\t\tuniform float depthPhi;\r\n\t\tuniform float normalPhi;\r\n\t\tuniform float radius;\r\n\t\tuniform int index;\r\n\t\t\r\n\t\t#include <common>\r\n\t\t#include <packing>\r\n\r\n\t\t#ifndef SAMPLE_LUMINANCE\r\n\t\t#define SAMPLE_LUMINANCE dot(vec3(0.2125, 0.7154, 0.0721), a)\r\n\t\t#endif\r\n\r\n\t\t#ifndef FRAGMENT_OUTPUT\r\n\t\t#define FRAGMENT_OUTPUT vec4(denoised, 1.)\r\n\t\t#endif\r\n\r\n\t\tfloat getLuminance(const in vec3 a) {\r\n\t\t\treturn SAMPLE_LUMINANCE;\r\n\t\t}\r\n\r\n\t\tconst vec3 poissonDisk[SAMPLES] = SAMPLE_VECTORS;\r\n\r\n\t\tvec3 getViewPosition(const in vec2 screenPosition, const in float depth) {\r\n\t\t\tvec4 clipSpacePosition = vec4(vec3(screenPosition, depth) * 2.0 - 1.0, 1.0);\r\n\t\t\tvec4 viewSpacePosition = cameraProjectionMatrixInverse * clipSpacePosition;\r\n\t\t\treturn viewSpacePosition.xyz / viewSpacePosition.w;\r\n\t\t}\r\n\t\t\r\n\t\tfloat getDepth(const vec2 uv) {\r\n\t\t#if DEPTH_VALUE_SOURCE == 1    \r\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).a;\r\n\t\t#else\r\n\t\t\treturn textureLod(tDepth, uv.xy, 0.0).r;\r\n\t\t#endif\r\n\t\t}\r\n\r\n\t\tfloat fetchDepth(const ivec2 uv) {\r\n\t\t\t#if DEPTH_VALUE_SOURCE == 1    \r\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).a;\r\n\t\t\t#else\r\n\t\t\t\treturn texelFetch(tDepth, uv.xy, 0).r;\r\n\t\t\t#endif\r\n\t\t}\r\n\r\n\t\tvec3 computeNormalFromDepth(const vec2 uv) {\r\n\t\t\tvec2 size = vec2(textureSize(tDepth, 0));\r\n\t\t\tivec2 p = ivec2(uv * size);\r\n\t\t\tfloat c0 = fetchDepth(p);\r\n\t\t\tfloat l2 = fetchDepth(p - ivec2(2, 0));\r\n\t\t\tfloat l1 = fetchDepth(p - ivec2(1, 0));\r\n\t\t\tfloat r1 = fetchDepth(p + ivec2(1, 0));\r\n\t\t\tfloat r2 = fetchDepth(p + ivec2(2, 0));\r\n\t\t\tfloat b2 = fetchDepth(p - ivec2(0, 2));\r\n\t\t\tfloat b1 = fetchDepth(p - ivec2(0, 1));\r\n\t\t\tfloat t1 = fetchDepth(p + ivec2(0, 1));\r\n\t\t\tfloat t2 = fetchDepth(p + ivec2(0, 2));\r\n\t\t\tfloat dl = abs((2.0 * l1 - l2) - c0);\r\n\t\t\tfloat dr = abs((2.0 * r1 - r2) - c0);\r\n\t\t\tfloat db = abs((2.0 * b1 - b2) - c0);\r\n\t\t\tfloat dt = abs((2.0 * t1 - t2) - c0);\r\n\t\t\tvec3 ce = getViewPosition(uv, c0).xyz;\r\n\t\t\tvec3 dpdx = (dl < dr) ?  ce - getViewPosition((uv - vec2(1.0 / size.x, 0.0)), l1).xyz\r\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(1.0 / size.x, 0.0)), r1).xyz;\r\n\t\t\tvec3 dpdy = (db < dt) ?  ce - getViewPosition((uv - vec2(0.0, 1.0 / size.y)), b1).xyz\r\n\t\t\t\t\t\t\t\t\t: -ce + getViewPosition((uv + vec2(0.0, 1.0 / size.y)), t1).xyz;\r\n\t\t\treturn normalize(cross(dpdx, dpdy));\r\n\t\t}\r\n\r\n\t\tvec3 getViewNormal(const vec2 uv) {\r\n\t\t#if NORMAL_VECTOR_TYPE == 2\r\n\t\t\treturn normalize(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t#elif NORMAL_VECTOR_TYPE == 1\r\n\t\t\treturn unpackRGBToNormal(textureLod(tNormal, uv, 0.).rgb);\r\n\t\t#else\r\n\t\t\treturn computeNormalFromDepth(uv);\r\n\t\t#endif\r\n\t\t}\r\n\r\n\t\tvoid denoiseSample(in vec3 center, in vec3 viewNormal, in vec3 viewPos, in vec2 sampleUv, inout vec3 denoised, inout float totalWeight) {\r\n\t\t\tvec4 sampleTexel = textureLod(tDiffuse, sampleUv, 0.0);\r\n\t\t\tfloat sampleDepth = getDepth(sampleUv);\r\n\t\t\tvec3 sampleNormal = getViewNormal(sampleUv);\r\n\t\t\tvec3 neighborColor = sampleTexel.rgb;\r\n\t\t\tvec3 viewPosSample = getViewPosition(sampleUv, sampleDepth);\r\n\t\t\t\r\n\t\t\tfloat normalDiff = dot(viewNormal, sampleNormal);\r\n\t\t\tfloat normalSimilarity = pow(max(normalDiff, 0.), normalPhi);\r\n\t\t\tfloat lumaDiff = abs(getLuminance(neighborColor) - getLuminance(center));\r\n\t\t\tfloat lumaSimilarity = max(1.0 - lumaDiff / lumaPhi, 0.0);\r\n\t\t\tfloat depthDiff = abs(dot(viewPos - viewPosSample, viewNormal));\r\n\t\t\tfloat depthSimilarity = max(1. - depthDiff / depthPhi, 0.);\r\n\t\t\tfloat w = lumaSimilarity * depthSimilarity * normalSimilarity;\r\n\t\t\r\n\t\t\tdenoised += w * neighborColor;\r\n\t\t\ttotalWeight += w;\r\n\t\t}\r\n\t\t\r\n\t\tvoid main() {\r\n\t\t\tfloat depth = getDepth(vUv.xy);\t\r\n\t\t\tvec3 viewNormal = getViewNormal(vUv);\t\r\n\t\t\tif (depth == 1. || dot(viewNormal, viewNormal) == 0.) {\r\n\t\t\t\tdiscard;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvec4 texel = textureLod(tDiffuse, vUv, 0.0);\r\n\t\t\tvec3 center = texel.rgb;\r\n\t\t\tvec3 viewPos = getViewPosition(vUv, depth);\r\n\r\n\t\t\tvec2 noiseResolution = vec2(textureSize(tNoise, 0));\r\n\t\t\tvec2 noiseUv = vUv * resolution / noiseResolution;\r\n\t\t\tvec4 noiseTexel = textureLod(tNoise, noiseUv, 0.0);\r\n      \t\tvec2 noiseVec = vec2(sin(noiseTexel[index % 4] * 2. * PI), cos(noiseTexel[index % 4] * 2. * PI));\r\n    \t\tmat2 rotationMatrix = mat2(noiseVec.x, -noiseVec.y, noiseVec.x, noiseVec.y);\r\n\t\t\r\n\t\t\tfloat totalWeight = 1.0;\r\n\t\t\tvec3 denoised = texel.rgb;\r\n\t\t\tfor (int i = 0; i < SAMPLES; i++) {\r\n\t\t\t\tvec3 sampleDir = poissonDisk[i];\r\n\t\t\t\tvec2 offset = rotationMatrix * (sampleDir.xy * (1. + sampleDir.z * (radius - 1.)) / resolution);\r\n\t\t\t\tvec2 sampleUv = vUv + offset;\r\n\t\t\t\tdenoiseSample(center, viewNormal, viewPos, sampleUv, denoised, totalWeight);\r\n\t\t\t}\r\n\t\t\r\n\t\t\tif (totalWeight > 0.) { \r\n\t\t\t\tdenoised /= totalWeight;\r\n\t\t\t}\r\n\t\t\tgl_FragColor = FRAGMENT_OUTPUT;\r\n\t\t}`\r\n\r\n};\r\n\r\nfunction generatePdSamplePointInitializer( samples, rings, radiusExponent ) {\r\n\r\n\tconst poissonDisk = generateDenoiseSamples(\r\n\t\tsamples,\r\n\t\trings,\r\n\t\tradiusExponent,\r\n\t);\r\n\r\n\tlet glslCode = 'vec3[SAMPLES](';\r\n\r\n\tfor ( let i = 0; i < samples; i ++ ) {\r\n\r\n\t\tconst sample = poissonDisk[ i ];\r\n\t\tglslCode += `vec3(${sample.x}, ${sample.y}, ${sample.z})${( i < samples - 1 ) ? ',' : ')'}`;\r\n\r\n\t}\r\n\r\n\treturn glslCode;\r\n\r\n}\r\n\r\nfunction generateDenoiseSamples( numSamples, numRings, radiusExponent ) {\r\n\r\n\tconst samples = [];\r\n\r\n\tfor ( let i = 0; i < numSamples; i ++ ) {\r\n\r\n\t\tconst angle = 2 * Math.PI * numRings * i / numSamples;\r\n\t\tconst radius = Math.pow( i / ( numSamples - 1 ), radiusExponent );\r\n\t\tsamples.push( new Vector3( Math.cos( angle ), Math.sin( angle ), radius ) );\r\n\r\n\t}\r\n\r\n\treturn samples;\r\n\r\n}\r\n\r\nexport { generatePdSamplePointInitializer, PoissonDenoiseShader };\r\n"],
  "mappings": ";;;;;;;;AAYA,IAAM,uBAAuB;AAAA,EAE5B,MAAM;AAAA,EAEN,SAAS;AAAA,IACR,WAAW;AAAA,IACX,kBAAkB,iCAAkC,IAAI,GAAG,CAAE;AAAA,IAC7D,sBAAsB;AAAA,IACtB,sBAAsB;AAAA,EACvB;AAAA,EAEA,UAAU;AAAA,IACT,YAAY,EAAE,OAAO,KAAK;AAAA,IAC1B,WAAW,EAAE,OAAO,KAAK;AAAA,IACzB,UAAU,EAAE,OAAO,KAAK;AAAA,IACxB,UAAU,EAAE,OAAO,KAAK;AAAA,IACxB,cAAc,EAAE,OAAO,IAAI,QAAQ,EAAE;AAAA,IACrC,iCAAiC,EAAE,OAAO,IAAI,QAAQ,EAAE;AAAA,IACxD,WAAW,EAAE,OAAO,EAAG;AAAA,IACvB,YAAY,EAAE,OAAO,EAAG;AAAA,IACxB,aAAa,EAAE,OAAO,EAAG;AAAA,IACzB,UAAU,EAAE,OAAO,EAAG;AAAA,IACtB,SAAS,EAAE,OAAO,EAAE;AAAA,EACrB;AAAA,EAEA;AAAA;AAAA,IAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASxB;AAAA;AAAA,IAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4I3B;AAEA,SAAS,iCAAkC,SAAS,OAAO,gBAAiB;AAE3E,QAAM,cAAc;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACD;AAEA,MAAI,WAAW;AAEf,WAAU,IAAI,GAAG,IAAI,SAAS,KAAO;AAEpC,UAAM,SAAS,YAAa,CAAE;AAC9B,gBAAY,QAAQ,OAAO,CAAC,KAAK,OAAO,CAAC,KAAK,OAAO,CAAC,IAAM,IAAI,UAAU,IAAM,MAAM,GAAG;AAAA,EAE1F;AAEA,SAAO;AAER;AAEA,SAAS,uBAAwB,YAAY,UAAU,gBAAiB;AAEvE,QAAM,UAAU,CAAC;AAEjB,WAAU,IAAI,GAAG,IAAI,YAAY,KAAO;AAEvC,UAAM,QAAQ,IAAI,KAAK,KAAK,WAAW,IAAI;AAC3C,UAAM,SAAS,KAAK,IAAK,KAAM,aAAa,IAAK,cAAe;AAChE,YAAQ,KAAM,IAAI,QAAS,KAAK,IAAK,KAAM,GAAG,KAAK,IAAK,KAAM,GAAG,MAAO,CAAE;AAAA,EAE3E;AAEA,SAAO;AAER;",
  "names": []
}
